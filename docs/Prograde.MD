The Prograde renderer architecture, with its modular ECS foundation and framegraph-based design, effectively addresses complex rendering challenges in a Vulkan environment. **Command buffer management is optimized by associating primary command buffers with specific Vulkan queues (graphics, compute, transfer) based on render graph node requirements, often batching tasks into queue-specific command batches or "islands" for submission.** Multi-window presentation is handled by managing separate swap chains and presentation queues per window, with the render graph's final output directed to the appropriate swap chain image, synchronized using a combination of binary semaphores for WSI and timeline semaphores for internal operations. **Resource format mismatches within the Prograde renderer are resolved by explicitly inserting specialized "BlitTask" or conversion nodes into the render graph; these nodes utilize Vulkan commands like `vkCmdBlitImage` or custom shader passes to transform resources into the expected formats for subsequent passes, with all necessary synchronization and layout transitions managed automatically by the render graph.**

# Prograde: A Vulkan Renderer Architecture for a Modular C++ Game Engine

## 1. Core Engine and Render System Architecture
### 1.1 Entity-Component-System (ECS) Foundation

The game engine is built upon an **Entity-Component-System (ECS) architecture**, which promotes modularity, data-oriented design, and efficient processing. In this framework, **Entities are conceptualized as "Layers,"** representing distinct logical sections or functionalities within the engine or game. These Layers can be equipped with **Modules, which act as Components**, imbuing the Layers with specific data and behaviors. **Systems are responsible for the core logic and processing**, operating on Layers that possess the requisite Modules. For instance, a Render System might iterate through all Layers, identify those containing both a Scene Module and a Renderer Module, and then proceed to render those scenes according to the specifications of the attached renderer. This ECS foundation allows for a highly decoupled and flexible system where new features can be added by creating new Modules and Systems without extensive modification to existing code, fostering a clean separation of concerns and enhancing maintainability and scalability.

### 1.2 Modular Render System and Renderer Graph Concept

The Render System within this engine is designed to be inherently **modular, centered around the concept of a Renderer Graph**. This graph is a data structure composed of **nodes, which represent individual "Renderers" (specific rendering techniques or pipelines), and edges, which signify "Resources" (data like textures, buffers, or even other renderers' outputs) flowing between these Renderers.** Each Renderer node can define a set of input resources it requires and a set of output resources it produces. The Renderer Graph culminates in a **final node whose responsibility is to bind the ultimate output resources to designated windows for display**, if windows are being used. This graph-based approach allows for the **engine to support multiple, potentially diverse, renderers operating simultaneously.** For example, a primary "Gameplay / Runtime Renderer" could produce the main game visuals, and its output could then be fed as an input resource to an "Editor Renderer." The Editor Renderer would then composite this gameplay view with its own GUI elements, such as toolbars, inspectors, and debug information, providing a seamless integrated development environment. This modularity extends to how renderers are managed and interact, offering significant flexibility in constructing complex rendering pipelines.

### 1.3 The Prograde Renderer: A Framegraph-Based Default

As a built-in default, the engine features the **"Prograde" renderer, which is explicitly designed as a framegraph renderer.** This choice provides a high-level abstraction for defining rendering pipelines. The Prograde renderer's operation begins by the Render System iterating through all active Layers. It identifies Layers that possess both a **Scene (defining the 3D world and its contents) and a ProgradeRenderer Module (indicating that this scene should be rendered using the Prograde framegraph).** For each such valid scene, the Prograde renderer then iterates over every camera associated with that scene that also has a **RenderGraph linked to it.** These camera-specific Render Graphs are the core of Prograde's rendering logic, dictating precisely how a particular scene is rendered from a given camera's perspective. They have full access to scene information (geometry, materials, lights) and camera properties (transform, projection). This design allows for highly customized rendering paths per camera, enabling effects like different rendering techniques for main views, shadow maps, or reflection probes, all managed within the same overarching Prograde framework.

## 2. Prograde Renderer: Internal Structure and Workflow
### 2.1 Camera-Specific Render Graphs

Within the Prograde renderer, **Render Graphs are fundamentally tied to individual cameras**, allowing for highly specialized rendering pipelines tailored to the specific needs and characteristics of each view. Each camera-specific Render Graph defines a sequence of rendering operations (passes or nodes) that transform the scene data, as viewed through that camera, into a set of output resources. These graphs have **direct access to the scene's entity data (including transforms, geometry, and materials) and the camera's intrinsic (e.g., field of view, aspect ratio) and extrinsic (position, orientation) properties.** This allows the Render Graph to make intelligent decisions about culling, level-of-detail, and the specific rendering techniques to employ (e.g., a deferred shading graph for the main camera, a simpler depth-only pass for a shadow-casting light's "camera"). The ability to define unique Render Graphs per camera is crucial for implementing a wide array of modern rendering features, from basic forward rendering to complex multi-pass deferred lighting, screen-space reflections, or specialized visualization modes for debugging or editor purposes, all within a unified and organized structure.

### 2.2 Resource Management: Persistent Storage and Composition Slots

Prograde's Render Graphs offer flexible mechanisms for managing the outputs they produce. **Resources generated by a Render Graph can be directed to "persistent storage,"** meaning they are intended to live beyond the lifetime of a single frame or even a single Render Graph execution. Examples include precomputed data like baked lightmaps, material textures, or dynamically generated content that needs to be reused, such as a dynamically updated environment map. This allows for efficient reuse of expensive-to-compute resources. Additionally, Render Graphs can **register their output resources onto "composition slots."** These slots act as named interfaces or mailboxes where intermediate rendering results are deposited. For instance, a camera's Render Graph might output its final color image to a "MainView" composition slot and a depth buffer to a "MainViewDepth" slot. This mechanism decouples the production of rendering data from its final consumption, enabling a more modular and composable rendering pipeline where different parts of the scene or different rendering effects can be combined in a later stage.

### 2.3 The Composition Layer: Aggregating Render Graph Outputs

The **Composition Layer is a crucial component within the Prograde renderer, responsible for aggregating and processing the outputs from various camera-specific Render Graphs.** Unlike the camera-specific graphs, the Composition Layer operates with a **renderer-wide scope, meaning it is agnostic to individual scenes or layers from which the inputs originated.** It defines a set of named "composition slots" that camera Render Graphs can write to. The Composition Layer itself is also a Render Graph (a "composition graph") that takes these slotted resources as inputs and combines them to produce the final output image(s) for the Prograde renderer. For example, a game might have a "Gameplay Layer" rendering the 3D world and a "HUD Layer" rendering user interface elements. Both could output to different composition slots (e.g., "GameplayColor" and "HUDColor"). The Composition Graph would then take these two textures, blend them appropriately, apply post-processing effects like bloom, color grading, or anti-aliasing, and finally output a single, composed image. This final image represents the complete rendered frame from the Prograde renderer's perspective, ready for presentation or further use.

## 3. Vulkan Integration and Low-Level Management in Prograde
### 3.1 Command Buffer Strategy

The Prograde renderer, with its framegraph architecture, requires a **sophisticated command buffer strategy to manage the potentially complex and dynamically defined rendering operations efficiently within Vulkan.** The core idea is to **decouple the high-level task definition within the render graph from the low-level command buffer recording and submission.** This allows the render graph system to perform optimizations, such as reordering passes for better performance or inserting necessary synchronization primitives automatically. The process typically involves linearizing or topologically sorting the render graph to determine a valid execution order. Command buffers are then allocated and recorded for each render pass or a group of compatible passes. A common strategy, inspired by existing render graph implementations like QuadBit's  and NVIDIA's best practices , involves **assigning primary command buffers based on the type of Vulkan queue they will be submitted to (e.g., graphics, compute, transfer).** A new primary command buffer is typically allocated when a task requires a different queue than its predecessor in the execution flow, ensuring commands are batched for compatible hardware queues.

The "Island" render graph system further refines this by **partitioning the render graph into "independent subgraphs," each associated with a specific queue or set of queue capabilities** . Each subgraph, representing a coherent set of rendering tasks, is translated into a "render command batch" submitted to the most appropriate idle queue. This approach simplifies management by using primary command buffers for these batches, which the render graph owns and manages, resetting and re-recording them as needed (e.g., per frame or when the graph structure changes). **NVIDIA's best practices also advise against submitting tiny command buffers due to driver overhead, suggesting batching work into reasonably sized command buffers** . Prograde should aim for this, potentially facilitated by its ECS architecture allowing parallel command buffer recording from different Layers or Modules, managed by the central Prograde system. The "L * T + N" rule for command pool allocation (L = buffered frames, T = recording threads, N = extra pools) and reusing command pools are also recommended for efficiency .

### 3.2 Synchronization and Resource State Management

**Effective synchronization and resource state management are paramount in Prograde due to Vulkan's explicit nature and the potential for multiple queues.** The render graph itself is ideally positioned to automate much of this complexity. By analyzing the entire frame's rendering operations, including resource reads and writes, the render graph can deduce necessary pipeline barriers, image layout transitions, and semaphore/fence synchronization points , . For instance, if a texture is written by one render pass and read by another, the render graph can automatically insert a `VkImageMemoryBarrier` to transition its layout (e.g., from `VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL` to `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL`) and ensure write completion before the read begins. The QuadBit system uses semaphores for inter-queue synchronization, where a task signals a semaphore upon completion, and a dependent task on a different queue waits on this semaphore . **NVIDIA advises minimizing barriers by preferring render passes or `VK_KHR_synchronization2` and grouping barriers into single calls** . Prograde's render graph nodes (corresponding to render passes) should leverage subpass dependencies for implicit synchronization where possible.

The "Island" render graph system introduces a sophisticated approach using **timeline semaphores for fine-grained synchronization between passes within subgraphs, particularly for multi-queue scenarios** . Timeline semaphores offer advantages over binary semaphores, such as not requiring a 1:1 signal-wait pairing . However, **Vulkan's WSI (Window System Integration) for swapchain operations often does not directly support timeline semaphores.** Therefore, a hybrid approach is necessary: **using timeline semaphores for internal render graph synchronization and dedicated binary semaphores (e.g., `PRESENT_COMPLETE`, `RENDER_COMPLETE`) for swapchain operations** . Prograde would need to implement this hybrid model, ensuring correct synchronization for image acquisition and presentation using binary semaphores, while internal passes use timeline semaphores for efficiency. The render graph's "baking" process would be responsible for setting up these semaphore signals and waits across queue submissions, including managing queue ownership transfers if `VK_SHARING_MODE_EXCLUSIVE` is used for resources .

### 3.3 Handling Resource Format Mismatches

In a modular renderer like Prograde, **different render passes might produce and consume resources with varying formats.** For example, an HDR rendering pass might output a texture in `VK_FORMAT_R16G16B16A16_SFLOAT`, while a subsequent post-processing pass expects `VK_FORMAT_R8G8B8A8_SRGB`. Vulkan does not perform automatic format conversions during resource binding, so the render graph system must manage these explicitly. The primary mechanism for this in Vulkan is **`vkCmdBlitImage`, which can copy image data between images with potential format conversion, scaling, or filtering.** The QuadBit render graph, for instance, uses a `BlitTask` node for such scenarios , . When Prograde's render graph compilation detects a format mismatch between a producer's output and a consumer's input, it can **automatically insert a `BlitNode` or a dedicated conversion pass.** This `BlitNode` would take the source image, perform the necessary Vulkan operations (e.g., `vkCmdBlitImage`) to convert it to the target format, and produce the converted resource for the subsequent pass.

This explicit insertion makes the conversion process a first-class citizen in the pipeline, aiding debugging and optimization. The `BlitNode` would also be responsible for ensuring input and output resources are in the correct layouts (e.g., `VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL` for source, `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL` for destination) by issuing pipeline barriers. The render graph system must track resource layouts and usage, automatically inserting these barriers. For more complex conversions, a custom shader invoked via a full-screen quad render pass might be used. The Khronos forums highlight the **critical importance of correct synchronization for `vkCmdBlitImage` operations**, ensuring source writes are complete and destination is ready before the blit, and the consumer sees the converted data . Unreal Engine's RDG also provides utility functions like `AddCopyTexturePass` for similar data manipulation tasks . Prograde should offer built-in utility nodes for common conversions, with the render graph managing scheduling, synchronization, and resource lifetimes.

## 4. Window Management and Presentation
### 4.1 Swap Chain Integration with Prograde Output

The final output of the Prograde renderer, after processing camera-specific render graphs and the composition layer, must be presented to the user via Vulkan swap chains. A swap chain manages a queue of images (`VkImage`s) destined for presentation on a surface (typically a window) . The Prograde architecture, where render graphs output to composition slots and the composition layer produces a final image, requires this final image to be directed to a swap chain image. This is often achieved by **blitting or copying the Prograde output texture onto one of the images acquired from the swap chain**, as swap chain images have specific ownership and usage requirements . The process involves creating and managing a swap chain for each window, choosing appropriate presentation modes (e.g., `VK_PRESENT_MODE_MAILBOX_KHR` for triple buffering, `VK_PRESENT_MODE_FIFO_KHR` for VSync) , , surface format, and swap extent.

A dedicated "Presenter" node or a specialized "BlitToSwapchain" task, potentially the final node in the renderer graph, would handle this. This node would **acquire the next available swap chain image using `vkAcquireNextImageKHR`**, record commands to transition the swap chain image to `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`, perform a `vkCmdBlitImage` (or `vkCmdCopyImage`) from the Prograde output texture, transition the swap chain image to `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR`, and then submit the command buffer and queue the image for presentation using `vkQueuePresentKHR` . The "Granite" engine's render graph designates a specific resource as the "backbuffer," which is then directed to the swap chain , . Prograde's composition graph output would be linked as this backbuffer. **Synchronization is critical: a semaphore signaled by `vkAcquireNextImageKHR` must be waited upon by the first command buffer writing to the swap chain image, and a semaphore signaled by the last command buffer writing to it must be waited upon by `vkQueuePresentKHR`** , . The engine must also handle swap chain recreation when the window is resized or other surface properties change .

### 4.2 Multi-Window Support and Presentation Queues

Supporting multiple windows in a Vulkan-based engine like the one described introduces complexity in managing swap chains and presentation queues. **Each window will typically require its own `VkSurfaceKHR` and consequently its own `VkSwapchainKHR`** . The Prograde renderer's architecture, allowing renderer graph outputs to be "bound to windows," suggests a design where different renderer instances or distinct branches of a master render graph could target different windows. The engine's WindowSystem would manage surface and swap chain creation per window. From Prograde's perspective, if each window displays independent content, it might necessitate a **separate Prograde renderer instance per window, or a more complex composition graph capable of managing multiple final outputs.** Each window's Prograde renderer would execute its camera-specific graphs and composition graph, culminating in rendering to its assigned swap chain image.

Vulkan allows presentation on queues supporting `VK_QUEUE_GRAPHICS_BIT` or `VK_QUEUE_COMPUTE_BIT` that also support presentation, determined by `vkGetPhysicalDeviceSurfaceSupportKHR`. While a single graphics queue is common for single windows, multi-window scenarios might involve more complex queue management. The "Island" render graph system is designed for multi-queue work distribution . **For multiple windows presented independently, each would likely have its own presentation queue (which could be the same physical queue or different ones).** Command buffers for rendering to each window's swap chain would be submitted, likely to a graphics queue. The final command buffer for each window's rendering would be submitted to that window's presentation queue. **Synchronization becomes more complex: each `vkAcquireNextImageKHR` signals a window-specific semaphore, and each window's rendering completion signals another semaphore for its `vkQueuePresentKHR`.** The engine must manage frame-in-flight resources (command buffers, semaphores, fences) per window to allow concurrent rendering and presentation. The `imageSharingMode` in `VkSwapchainCreateInfoKHR` is relevant if graphics and presentation queues differ, with `VK_SHARING_MODE_EXCLUSIVE` preferred for performance if explicit ownership transfer is managed .

## 5. Advanced Features and Future Considerations
### 5.1 Renderer Initialization and Hot Reloading

**Renderer initialization for Prograde involves creating the Vulkan instance, device, and necessary queues (graphics, compute, present).** The Prograde renderer itself is then initialized, setting up structures for render graphs, resources, and shaders. Default render graphs (e.g., basic forward/deferred pipelines) could be pre-compiled. **Hot reloading is crucial for rapid iteration, especially for shaders and potentially render graph configurations.** For shader hot reloading, the asset system monitors shader files. Upon a change, affected `VkShaderModule`s are recompiled, and `VkPipeline` objects using them are updated (old ones destroyed, new ones created). This requires careful synchronization, ensuring GPU operations with old pipelines complete (using fences or deferred destruction) before they are destroyed.

**Hot reloading of render graph configurations is more complex.** If render graphs are defined externally (e.g., scripts), changes could trigger re-compilation: parsing the new definition, validating, creating new Vulkan resources (render passes, framebuffers, pipelines if descriptors change significantly), and swapping the old graph with the new one. This must be meticulously synchronized. The render graph itself might own its Vulkan resources, simplifying lifetime management during reloads, similar to the "Granite" render graph . **Window resizing also necessitates a form of hot reloading: the swap chain and dependent resources (depth buffers, offscreen targets) must be recreated with new dimensions.** The Prograde renderer associated with that window would update its render targets and potentially recompile graph parts dependent on screen-relative sizes or swapchain properties, involving cleanup and re-initialization.

### 5.2 Integration of an Editor Renderer

The engine's architecture, allowing multiple renderers and redirection of outputs, is well-suited for **integrating an Editor Renderer that uses the Prograde renderer as a viewport.** In this scenario, the "Gameplay / Runtime Renderer" (an instance of Prograde) renders the game world. Its final composed image becomes an input to the "Editor Renderer." The Editor Renderer, another system likely leveraging ECS, draws GUI elements, gizmos, and other editor visuals. It takes the Prograde output (a texture) and renders it as an ImGui image or a textured quad within its own pipeline. This requires Prograde to output its final image to a texture resource manageable by the Editor Renderer, potentially as a persistent resource or a dedicated output slot.

**Careful synchronization is needed between these renderers.** Prograde must complete its frame and all GPU work (writing to the output texture, transitioning its layout to `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL`) before the Editor Renderer samples it. This is typically managed by semaphores: Prograde signals a semaphore upon frame completion, and the Editor Renderer waits on this semaphore. If the editor allows interactive scene modification, these changes (e.g., to ECS components like transforms or camera parameters) must be reflected in Prograde's next frame. For multi-window editors with different viewports, each viewport could have a separate Prograde instance or a distinct render graph within a central Prograde system, each producing an output texture for the editor. The engine's modularity supports this composable rendering.

### 5.3 Path-Based Rendering and Ray Tracing Integration (Future)

Integrating path-based rendering, such as ray tracing, into Prograde as a future enhancement aligns with its framegraph architecture. **Ray tracing can be conceptualized as specialized render passes within the render graph**, like a "RayTracedShadows" or "RayTracedReflections" pass. These passes would declare input resources (e.g., scene BVH, material textures) and output resources (e.g., ray-traced image). The render graph would handle scheduling, synchronization, and resource management. The "Island" render graph's multi-queue approach could be beneficial, as **ray tracing operations, especially acceleration structure (AS) builds/updates, can be offloaded to dedicated compute or async compute queues** , . Prograde's ray tracing subgraph would manage AS construction (BLAS for geometry, TLAS for instances) ,  and dispatch of ray tracing pipelines (`VkRayTracingPipelineKHR`).

**Key aspects of Vulkan ray tracing integration include:**
*   **Acceleration Structure (AS) Management**: Creating, building, and updating BLAS (for model geometry) and TLAS (for scene instances) using `VK_KHR_acceleration_structure` , . This involves preparing geometry/instance data, querying memory requirements, allocating buffers, and recording build commands (`vkCmdBuildAccelerationStructuresKHR`) , .
*   **AS Compaction**: Using `VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR` to reduce AS memory footprint after an initial build , .
*   **Synchronization**: Properly synchronizing AS build/update operations using `VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR` and appropriate access flags , . This includes barriers for source/destination AS, scratch buffers, and input geometry/instance buffers.
*   **Skinned Meshes**: For animated characters, a compute-based skinning pass (e.g., a "Compute Skin Cache" as in Unreal Engine , ) can pre-skin vertex positions for BLAS updates, avoiding redundant skinning in multiple passes .
*   **Ray Tracing Pipeline & Shaders**: Creating `VkRayTracingPipelineKHR` with new shader stages (`rgen`, `rmiss`, `rchit`, etc.) and managing the Shader Binding Table (SBT) which links geometry instances to shaders , .
*   **Dispatching Rays**: Using `vkCmdTraceRaysKHR` to initiate ray tracing work.
The render graph's declarative nature helps manage complex dependencies and resource transitions for ray tracing. For example, a ray tracing node would declare the TLAS as an input, and the framegraph ensures it's built and ready.

## 6. Addressing Specific Design Questions
### 6.1 Command Buffer Handling in a Complex Render Graph

In the context of Prograde's complex render graph, **command buffer handling is managed by associating primary command buffers with specific Vulkan queues (graphics, compute, transfer) based on the requirements of each render graph node.** As the render graph is processed (typically after a topological sort), tasks are grouped, and command buffers are allocated and recorded for these task groups. A key strategy, observed in systems like QuadBit's  and NVIDIA's best practices , is to **initiate a new primary command buffer when a render graph node requires a different queue type than the preceding node.** This ensures that commands destined for a specific hardware queue are batched together, minimizing queue switches and submission overhead. The "Island" render graph system further optimizes this by partitioning the graph into "independent subgraphs," each targeting a specific queue, and translating these subgraphs into "render command batches" submitted to the most appropriate idle queue . This approach simplifies management by using primary command buffers for these batches, which the render graph system centrally manages, including their creation, resetting, and submission. This systematic assignment and control flow are crucial for maintaining performance and correctness in a multi-pass rendering setup.

### 6.2 Multi-Window Presentation with Vulkan Queues and Command Buffers

**Multi-window presentation in Vulkan requires careful management of swap chains, presentation queues, and command buffers on a per-window basis.** Each window typically has its own `VkSurfaceKHR` and `VkSwapchainKHR` . The Prograde renderer, or a higher-level composition system, must be capable of rendering to multiple swap chains. This could involve separate Prograde renderer instances per window or a more complex master render graph with multiple final outputs. **Command buffers for rendering to each window's swap chain images are recorded and submitted, likely to a graphics queue.** The final command buffer containing rendering commands for a specific window's swap chain image is then submitted to that window's presentation queue. It's crucial to ensure that the chosen presentation queue supports presentation to the target window's surface, which is determined by `vkGetPhysicalDeviceSurfaceSupportKHR`. **Synchronization is paramount: each window's swap chain image acquisition (`vkAcquireNextImageKHR`) signals a unique semaphore that the corresponding rendering commands must wait on.** Similarly, the completion of rendering for each window must signal another unique semaphore that its respective `vkQueuePresentKHR` call will wait on . The engine must manage frame-in-flight resources (command buffers, semaphores, fences) independently for each window to enable concurrent and correct rendering and presentation across all windows.

### 6.3 Resource Format Mismatch Resolution in Prograde

The Prograde renderer, with its framegraph architecture, **handles resource format mismatches by explicitly inserting specialized conversion nodes into the render graph.** When the render graph is compiled or executed, and a resource produced by one pass (e.g., in HDR format `VK_FORMAT_R16G16B16A16_SFLOAT`) is consumed by a subsequent pass expecting a different format (e.g., LDR sRGB `VK_FORMAT_R8G8B8A8_SRGB`), the system can automatically inject a "BlitTask" or a dedicated conversion pass , . This `BlitNode` would take the source image as input and produce an image in the desired target format, typically using Vulkan's `vkCmdBlitImage` command, which can perform format conversion, scaling, and filtering. For more complex conversions not easily handled by a simple blit (e.g., custom tone mapping or complex data transformations), a full-screen quad render pass with a custom shader might be employed. **The render graph's synchronization mechanisms ensure that the conversion operation occurs after the producer pass has finished writing to the source resource and before the consumer pass begins reading from the converted resource.** This involves automatically inserting the necessary pipeline barriers to transition image layouts (e.g., to `VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL` for the source, `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL` for the destination, and then to `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL` for the consumer). This approach keeps render pass logic clean and delegates format adaptation to specialized, well-integrated components within the render graph.